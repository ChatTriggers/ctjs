package com.chattriggers.ctjs.launch

import com.chattriggers.ctjs.engine.ILoader
import com.chattriggers.ctjs.launch.generation.InjectorGenerator
import org.objectweb.asm.Handle
import org.objectweb.asm.Opcodes
import org.objectweb.asm.Type
import java.lang.invoke.CallSite
import java.lang.invoke.MethodHandle
import java.lang.invoke.MethodHandles
import java.lang.invoke.MethodType
import java.lang.invoke.MutableCallSite
import kotlin.reflect.jvm.javaMethod

internal object InvokeDynamicSupport {
    internal val BOOTSTRAP_HANDLE = Handle(
        Opcodes.H_INVOKESTATIC,
        InvokeDynamicSupport::class.qualifiedName!!.replace('.', '/'),
        "bootstrapInvokeMixin",
        Type.getMethodDescriptor(::bootstrapInvokeMixin.javaMethod),
        false,
    )

    @JvmStatic
    fun bootstrapInvokeMixin(
        lookup: MethodHandles.Lookup,
        name: String,
        type: MethodType,
        loaderFieldHandle: MethodHandle,
        mixinId: Int,
    ): CallSite {
        // This method is called when the invokedynamic instruction generated by InjectorGenerator is first encountered
        // (i.e. the first time the mixin handler method is called). This method's job is to return a CallSite object,
        // which contains the actual target we want to call in the future (i.e. in future invocations of the mixin
        // handler method).

        val callSite = MutableCallSite(type)
        val loader = loaderFieldHandle.invoke()

        // We link to an intermediary method (initInvokeMixin) that will do the function lookup when the method is first
        // called. This intermediary method doesn't meet the required type of (Object[])Object, so we need to meddle
        // with it to make sure it fits. It requires the call site, loader, and mixinId as parameters, which are all
        // effectively constants at this point in time (we have them now and they will not change). We thus create a new
        // MethodHandle with these arguments automatically provided, which gives us a handle that only needs that final
        // Array<Any?> argument.
        val initHandle = MethodHandles.insertArguments(
            lookup.findStatic(
                InvokeDynamicSupport::class.java,
                "initInvokeMixin",
                MethodType.methodType(
                    Any::class.java,
                    MutableCallSite::class.java,
                    String::class.java,
                    ILoader::class.java,
                    Int::class.java,
                    Array<Any?>::class.java,
                )
            ),
            0,
            callSite,
            name,
            loader,
            mixinId,
        )

        // Bind the target to the callSite and return it
        callSite.target = initHandle.asType(type)
        return callSite
    }

    @JvmStatic
    fun initInvokeMixin(callSite: MutableCallSite, name: String, loader: ILoader, mixinId: Int, args: Array<Any?>): Any? {
        // Make an initial lookup to the target function. This is where we want our mixin handler method to point to
        val mixinCallback = loader.invokeMixinLookup(mixinId)

        check((mixinCallback.handle == null) == (mixinCallback.method == null))

        val targetHandle = if (mixinCallback.handle == null) {
            // If we don't have a handle, that means the user hasn't called attach() on the callback, meaning this mixin
            // is "unused"...
            val (methodName, injectionType) = InjectorGenerator.disassembleIndyName(name)

            error("$injectionType mixin into method $methodName was called, but has no handler. Did you forget to " +
                        "call attach()?")
        } else {
            mixinCallback.handle!!
        }

        // Until we /ct load, however. When we reload, we need to re-resolve all JS invocation targets since our old
        // engine context has been thrown away and recreated. It is also possible that the user has changed their code
        // in the handler function.
        val initTarget = callSite.target

        // This switch point will be our indicator to know if the user has reloaded. As soon as the user reloads, this
        // switch will get flipped, immediately making the call site link back to the fallback MethodHandle. The
        // fallback method (initTarget above) is this method, so we will rerun the lookup and get a handle to the new
        // method.
        //
        // Note that the mechanism for flipping these switches is in MixinCallback. When the user calls attach(), the
        // invalidator gets invalidated, as the method has changed. This of course happens for all mixins when the user
        // /ct loads, since the scripts are re-run.
        val guardedTarget = mixinCallback.invalidator.guardWithTest(targetHandle, initTarget)

        // We now have a target that is very fast to call back into the target method, and can survive reloads or calls
        // to attach(), so we want our call site to now point to that target.
        callSite.target = guardedTarget

        // This method invocation occurred because we actually tried to call the target method with the supplied mixin
        // arguments. So in addition to performing the call site rebinding, we also need to make the actual method call.
        return targetHandle.invoke(args)
    }
}
